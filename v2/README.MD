# tetr v2

Backend state controlled tetr.

Node based backend using express and postgress

HTML, CSS, and JS based frontend using no libraries.

# Todo List:
1. Do everything
2. email verification should be added via nodemailer.

# Password Security:

I probably went a bit crazy on this but it was fun and I wanted to learn so I did it.

### Setup stuff:

1. The number of salt rounds for bcrypt is determined based off the speed of the hardware that the server is being ran off of. This is based on settings.bcrypt.minTimePerPHash which is the minimum time in milliseconds for the hash to take, and settings.bcrypt.minSaltRounds which is the lowest salt rounds that the server could use. This is to keep the number of salt rounds high, while still keeping the server fast.
1. The pepper (a secret separate salt applied to all passwords) is in setttings.bcrypt.pepper. This can be any string. It is recommened for this to be a very long and complex string. Personally, I made a script to generate my pepper, which is genPepper.js. This script generates large numbers of SHA512 hashes based off Math.random(), crypto.randomBytes(), and your computers time in nanoseoconds and then combines them to generate a practically completely random SHA512 hash. This generates a pepper which should be basically unbruteforceable. genPepper.js will take up to 15 seconds to run. If you are very paranoid, you could generate a few of these and concatenate these together.


### on every password:

1. The Client hashes the password with SHA512 to keep the raw password off the server.
1. The Server hashes the SHA512 hashed password concatenated with the pepper with SHA512.
1. The Server hashes the SHA512 hashed password pepper combination with bcrypt with a salt.
1. This final bcrypt hash is the final password hash. It can now be stored, or be verified against the original password hash.

Theoretically this approach forces a attacker who has DB access to bruteforce the pepper first by creating a user account with a known password. Bruteforcing this pepper though should be impossible assuming you use a strong pepper, like the ones generated by genPepper.js.

If a RCE vulnerability or vulnerability that can read data from the server's RAM or hard drive is found instead of a vulnerability that just allows DB access, security is reduced to bcrypt without the pepper. Uncommon passwords should still be secure without the pepper, but common passwords may be bruteforceable with a known pepper.

This approach to hashing is also unique as far as I know. This means that a attacker would need to write custom password cracking code for this specfic service. This obviously does not increase hashing time, but a unmotivated attacker may not think the time investment is worth the reward.

For more security a user specific pepper could be used. The best way to do this would be to write a 2nd backend pepper authentication server. The backend server would send the userid and client hashed SHA512 password to the pepper server. The pepper server would then send back a SHA512 hashed password pepper combination that used a unique pepper to the userid sent. The pepper server would effectively take care of step 2. The reason this would be more secure is because there would be a 2nd db that would need to be hacked to get the peppers. This means that even if a RCE vulnerability is found on the main server, the hashes would still be secure. The hackers would then have to find a vulnerability in the pepper server to steal the peppers. Without the 2nd vulnerability, the hashes would be practically uncrackable. With a RCE vulnability though the hackers may be able to do a man in the middle attack and steal passwords from the server. These would still be SHA512 hashed, but SHA512 is easily crackable for a attacker.

Another approach for more security is writing a authentication server. Because I am using JWTs the tokens can be verified by the main game server, but could redirect to a authentication server for issuing tokens. This would mean that the authentication server could have a very simple codebase, which would be potenially harder to hack. This basically means that if a mistake is made somewhere else in the main game server that causes RCE (unrelated to authentication code), the authentication server with hashed passwords would still be secure.

Another thing that might make sense is a better hashing algorithm. Argon2 might be better.

I am not using any of these approaches, because it is not worth the effort for a simple tetris game, with very little valuable user data.
